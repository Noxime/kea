//! Keyboard API

/// Event generated by the keyboard
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Event {
    Up(Key, Mods),
    Down(Key, Mods),
    /// A properly translated text input. If you are implementing a text input
    /// in your game, you want to use this, as it respects keymappings and
    /// should be closest to the truth
    Text(char),
}

/// A key scancode
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct Key(u32);

impl Key {
    /// The raw scancode of the key
    ///
    /// This is independent of the users keyboard map. This is useful for when
    /// the physical location of the key is more important than its semantic
    /// meaning, like controls in games (eg. WASD controls on a dvorak-keyboard)
    pub fn code(&self) -> u32 {
        self.0
    }

    /// Get the semantic / symbolic meaning of a key, if it has one
    ///
    /// This is useful for when the semantic meaning of a key is more important
    /// than its location, for example **"Page Up"**
    pub fn virt(&self) -> Option<VirtualKey> {
        todo!("Virtual keycode translation");
        #[allow(unreachable_code)]
        match self.code() {
            0x01 => Some(VirtualKey::Escape),
            0x02 => Some(VirtualKey::Key1),
            0x03 => Some(VirtualKey::Key2),
            0x04 => Some(VirtualKey::Key3),
            0x05 => Some(VirtualKey::Key4),
            0x06 => Some(VirtualKey::Key5),
            0x07 => Some(VirtualKey::Key6),
            0x08 => Some(VirtualKey::Key7),
            0x09 => Some(VirtualKey::Key8),
            0x0A => Some(VirtualKey::Key9),
            0x0B => Some(VirtualKey::Key0),

            0x0C => Some(VirtualKey::Minus),
            0x0D => Some(VirtualKey::Equals),

            0x0E => Some(VirtualKey::Back),
            0x0F => Some(VirtualKey::Tab),

            0x10 => Some(VirtualKey::Q),
            0x11 => Some(VirtualKey::W),
            0x12 => Some(VirtualKey::E),
            0x13 => Some(VirtualKey::R),
            0x14 => Some(VirtualKey::T),
            0x15 => Some(VirtualKey::Y),
            0x16 => Some(VirtualKey::U),
            0x17 => Some(VirtualKey::I),
            0x18 => Some(VirtualKey::O),
            0x19 => Some(VirtualKey::P),

            0x1A => Some(VirtualKey::LBracket),
            0x1B => Some(VirtualKey::RBracket),

            0x1C => Some(VirtualKey::Return),
            0x1D => Some(VirtualKey::LControl),

            0x1E => Some(VirtualKey::A),
            0x1F => Some(VirtualKey::S),
            0x20 => Some(VirtualKey::D),
            0x21 => Some(VirtualKey::F),
            0x22 => Some(VirtualKey::G),
            0x23 => Some(VirtualKey::H),
            0x24 => Some(VirtualKey::J),
            0x25 => Some(VirtualKey::K),
            0x26 => Some(VirtualKey::L),

            0x27 => Some(VirtualKey::Semicolon),
            0x28 => Some(VirtualKey::Apostrophe),
            0x29 => Some(VirtualKey::Grave),

            _ => None,
        }
    }
}

impl From<u32> for Key {
    fn from(scancode: u32) -> Key {
        Key(scancode)
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum VirtualKey {
    Key1,
    Key2,
    Key3,
    Key4,
    Key5,
    Key6,
    Key7,
    Key8,
    Key9,
    Key0,
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
    Escape,
    F1,
    F2,
    F3,
    F4,
    F5,
    F6,
    F7,
    F8,
    F9,
    F10,
    F11,
    F12,
    F13,
    F14,
    F15,
    F16,
    F17,
    F18,
    F19,
    F20,
    F21,
    F22,
    F23,
    F24,
    Snapshot,
    Scroll,
    Pause,
    Insert,
    Home,
    Delete,
    End,
    PageDown,
    PageUp,
    Left,
    Up,
    Right,
    Down,
    Back,
    Return,
    Space,
    Compose,
    Caret,
    Numlock,
    Numpad0,
    Numpad1,
    Numpad2,
    Numpad3,
    Numpad4,
    Numpad5,
    Numpad6,
    Numpad7,
    Numpad8,
    Numpad9,
    AbntC1,
    AbntC2,
    Add,
    Apostrophe,
    Apps,
    At,
    Ax,
    Backslash,
    Calculator,
    Capital,
    Colon,
    Comma,
    Convert,
    Decimal,
    Divide,
    Equals,
    Grave,
    Kana,
    Kanji,
    LAlt,
    LBracket,
    LControl,
    LShift,
    LMod,
    Mail,
    MediaSelect,
    MediaStop,
    Minus,
    Multiply,
    Mute,
    MyComputer,
    NavigateForward,
    NavigateBackward,
    NextTrack,
    NoConvert,
    NumpadComma,
    NumpadEnter,
    NumpadEquals,
    OEM102,
    Period,
    PlayPause,
    Power,
    PrevTrack,
    RAlt,
    RBracket,
    RControl,
    RShift,
    RMod,
    Semicolon,
    Slash,
    Sleep,
    Stop,
    Subtract,
    Sysrq,
    Tab,
    Underline,
    Unlabeled,
    VolumeDown,
    VolumeUp,
    Wake,
    WebBack,
    WebFavorites,
    WebForward,
    WebHome,
    WebRefresh,
    WebSearch,
    WebStop,
    Yen,
    Copy,
    Paste,
    Cut,
}

/// Current state of the keyboard modifiers
///
/// Using this prevents bugs and errors when tracking modifiers is hard due to
/// unfocused game and such
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub struct Mods {
    pub shift: bool,
    pub ctrl: bool,
    pub alt: bool,
    pub mode: bool,
}
